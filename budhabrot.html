
<!DOCTYPE html>
<html>
  <meta charset="UTF-8">
  <title>Mandelbrot set</title>

  <style>

  body {
    background-color: black;
  }

  #container {
    width: 100%;
    text-align: center;
  }

  #plot {
    display: inline-block;
  }
  </style>

  <body>
    <div id="container">
      <canvas id="plot" ></canvas>
    </div>

    <script>
    // Get canvas object and context
    var canvas = document.getElementById('plot');
    var ctx = canvas.getContext('2d');

    ctx.canvas.height = window.innerHeight - 20;
    ctx.canvas.width  = ctx.canvas.height;

    // Specify the range of plot in the complex plane.
    // We assume it's of the form [xMin, xMax, yMin, yMax]
    var range = [-2, 2, -2, 2];

    // The stride is inversely proportional to resolution. Lesser values implies higher resolution
    // at computational cost. It is the amount of pixels skiped per xStep or yStep.
    let stride = 1.0;

    // Number of steps without point blowing up to be considered in the Mandelbrot set
    let maxSteps = 512;

    // In all the functions below we model a complex number as a hash {"Re": x, "Im": y}
    function squared_modulus(z) {
      return z.Re*z.Re + z.Im*z.Im;
    }

    // Compute one step of the iteration. Note that if z = x + iy and c = a + bi, then we have:
    // z^2 + c = (x^2 - y^2 + a) + i(2xy + b)
    function compute(z, c) {
      return {
        "Re": z.Re*z.Re - z.Im*z.Im + c.Re,
        "Im": 2*z.Re*z.Im + c.Im
        }
    }

    // Compute number of iterations before point modulus get bigger than 2
    function computeTrajectory(c) {
      var trajectory = [];
      var z = {"Re": 0.0, "Im": 0.0};
      for(let steps = 0; steps <= maxSteps; steps++) {
        z = compute(z, c);
        trajectory.push(z);
        if(squared_modulus(z) > 4) {
          return trajectory;
        }
      }
      return null;
    }

    function color(c) {
      let intensity = 255.0*c;
      let color = [intensity, intensity, intensity];
      return "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
    }

    class Box {
      constructor(xmin, xmax, ymin, ymax) {
        this.xmin = xmin;
        this.xmax = xmax;
        this.ymin = ymin;
        this.ymax = ymax;
        this.count = 0;
      }
    }

    // Function to plot set with given stride
    function plot(context, stride) {

      let [xMin, xMax, yMin, yMax] = range;

      // We are transforming [min, max] to [0, canvasLinearSize] linearly.
      // Here, Scale is our angular coefficient and Offset is our linear coefficient.
      let xScale = context.canvas.width/(xMax - xMin);
      let yScale = context.canvas.height/(yMax - yMin);

      let xOffset = -xScale*xMin;
      let yOffset = -yScale*yMin;

      // Compute step size in plots dimensions (stepFactor is in pixels)
      let xStep = stride/xScale;
      let yStep = stride/yScale;

      // Initialize boxes
      let boxes = [];
      let xIndex = {};
      let yIndex = {};
      for(let x = xMin; x <= xMax; x += xStep){
        xIndex[Math.floor(x/xStep)] = boxes.length;
        boxes.push([]);
        for(let y = yMin; y <= yMax; y += yStep){
          yIndex[Math.floor(y/yStep)] = boxes[boxes.length - 1].length;
          boxes[boxes.length - 1].push(0);
        }
      }

      // Sample trajectories, incrementing boxes if trajectories escapes
      let max = 1;
      for(let i=0; i < 10000000; i++) {
        let x = xMin + (xMax - xMin)*Math.random();
        let y = yMin + (yMax - yMin)*Math.random();
        let c = {'Re': x, 'Im': y};
        let trajectory = computeTrajectory(c);
        if(trajectory) {
          for(let j = 0; j < trajectory.length; j++) {
            let p = trajectory[j];
            let xi = xIndex[Math.floor(p['Re']/xStep)];
            let yi = yIndex[Math.floor(p['Im']/yStep)];
            if(boxes[xi] !== undefined && boxes[xi][yi] !== undefined) {
              boxes[xi][yi] += 1
              if(boxes[xi][yi] > max) max = boxes[xi][yi];
            };
          }
        }
      }

      for(let x = xMin; x <= xMax; x += xStep){
        for(let y = yMin; y <= yMax; y += yStep){
          xi = xIndex[Math.floor(x/xStep)];
          yi = yIndex[Math.floor(y/yStep)];
          let c = boxes[xi][yi]/max;
          context.fillStyle = color(c);
          context.fillRect(yScale*y + yOffset - stride/2, xScale*x + xOffset - stride/2, stride, stride);
        }
      }
    }

    plot(ctx, 1);
  </script>
  </body>
</html>
